//      scorelayout.c
//      
//      Copyright 2012 Richard Shann 
//      
//      This program is free software; you can redistribute it and/or modify
//      it under the terms of the GNU General Public License as published by
//      the Free Software Foundation; either version 3 of the License, or
//      (at your option) any later version.
//      
//      This program is distributed in the hope that it will be useful,
//      but WITHOUT ANY WARRANTY; without even the implied warranty of
//      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//      GNU General Public License for more details.
//      
//      You should have received a copy of the GNU General Public License
//      along with this program; if not, write to the Free Software
//      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
//      MA 02110-1301, USA.


#include "scorelayout.h"
#include "exportlilypond.h"
#include "utils.h"
#include "print.h"
//generated by cairo_svg2path from piano_staff.svg
static cairo_path_data_t piano_brace_data[] = {
	{.header.type = 0, .header.length = 2},
	{.point.x = 13.694762, .point.y = 15.134294},
	{.header.type = 0, .header.length = 2},
	{.point.x = 13.694762, .point.y = 34.647228},
	{.header.type = 2, .header.length = 4},
	{.point.x = 13.694745, .point.y = 37.873117},
	{.point.x = 13.456160, .point.y = 40.450299},
	{.point.x = 12.979007, .point.y = 42.378764},
	{.header.type = 2, .header.length = 4},
	{.point.x = 12.533633, .point.y = 44.307289},
	{.point.x = 11.849690, .point.y = 45.797498},
	{.point.x = 10.927179, .point.y = 46.849380},
	{.header.type = 2, .header.length = 4},
	{.point.x = 10.036446, .point.y = 47.901323},
	{.point.x = 8.748092, .point.y = 48.830499},
	{.point.x = 7.062105, .point.y = 49.636952},
	{.header.type = 2, .header.length = 4},
	{.point.x = 9.734241, .point.y = 50.899267},
	{.point.x = 11.499767, .point.y = 52.722581},
	{.point.x = 12.358688, .point.y = 55.106874},
	{.header.type = 2, .header.length = 4},
	{.point.x = 13.249387, .point.y = 57.491228},
	{.point.x = 13.694745, .point.y = 61.102772},
	{.point.x = 13.694762, .point.y = 65.941541},
	{.header.type = 1, .header.length = 2},
	{.point.x = 13.694762, .point.y = 83.666226},
	{.header.type = 2, .header.length = 4},
	{.point.x = 13.694745, .point.y = 88.119297},
	{.point.x = 14.251441, .point.y = 91.450330},
	{.point.x = 15.364854, .point.y = 93.659376},
	{.header.type = 2, .header.length = 4},
	{.point.x = 15.937439, .point.y = 94.781380},
	{.point.x = 16.557760, .point.y = 95.675508},
	{.point.x = 17.225817, .point.y = 96.341727},
	{.header.type = 2, .header.length = 4},
	{.point.x = 17.925643, .point.y = 97.042993},
	{.point.x = 18.434624, .point.y = 97.463756},
	{.point.x = 18.752761, .point.y = 97.604034},
	{.header.type = 2, .header.length = 4},
	{.point.x = 19.102663, .point.y = 97.744242},
	{.point.x = 19.532113, .point.y = 97.884511},
	{.point.x = 20.041117, .point.y = 98.024788},
	{.header.type = 1, .header.length = 2},
	{.point.x = 20.041117, .point.y = 99.602655},
	{.header.type = 2, .header.length = 4},
	{.point.x = 14.442310, .point.y = 99.427312},
	{.point.x = 10.815824, .point.y = 98.112447},
	{.point.x = 9.161650, .point.y = 95.658006},
	{.header.type = 2, .header.length = 4},
	{.point.x = 7.412016, .point.y = 93.028214},
	{.point.x = 6.537207, .point.y = 88.487468},
	{.point.x = 6.537217, .point.y = 82.035749},
	{.header.type = 1, .header.length = 2},
	{.point.x = 6.537217, .point.y = 63.206580},
	{.header.type = 2, .header.length = 4},
	{.point.x = 6.537207, .point.y = 60.787187},
	{.point.x = 6.362244, .point.y = 58.735972},
	{.point.x = 6.012330, .point.y = 57.052911},
	{.header.type = 2, .header.length = 4},
	{.point.x = 5.694207, .point.y = 55.369866},
	{.point.x = 5.026171, .point.y = 53.879675},
	{.point.x = 4.008217, .point.y = 52.582286},
	{.header.type = 2, .header.length = 4},
	{.point.x = 3.022060, .point.y = 51.249883},
	{.point.x = 1.685986, .point.y = 50.373300},
	{.point.x = -0.000008, .point.y = 49.952520},
	{.header.type = 1, .header.length = 2},
	{.point.x = -0.000008, .point.y = 49.373968},
	{.header.type = 2, .header.length = 4},
	{.point.x = 4.358134, .point.y = 48.006509},
	{.point.x = 6.537207, .point.y = 43.676162},
	{.point.x = 6.537217, .point.y = 36.382874},
	{.header.type = 1, .header.length = 2},
	{.point.x = 6.537217, .point.y = 15.975830},
	{.header.type = 2, .header.length = 4},
	{.point.x = 6.537207, .point.y = 10.120270},
	{.point.x = 7.443829, .point.y = 5.965213},
	{.point.x = 9.257083, .point.y = 3.510685},
	{.header.type = 2, .header.length = 4},
	{.point.x = 11.102126, .point.y = 1.056314},
	{.point.x = 14.696800, .point.y = -0.258578},
	{.point.x = 20.041117, .point.y = -0.433981},
	{.header.type = 1, .header.length = 2},
	{.point.x = 20.041117, .point.y = 1.143903},
	{.header.type = 2, .header.length = 4},
	{.point.x = 18.068795, .point.y = 1.740052},
	{.point.x = 16.462326, .point.y = 3.212732},
	{.point.x = 15.221705, .point.y = 5.561917},
	{.header.type = 2, .header.length = 4},
	{.point.x = 14.203726, .point.y = 7.490478},
	{.point.x = 13.694745, .point.y = 10.681285},
	{.point.x = 13.694762, .point.y = 15.134294},

};

static cairo_path_t piano_brace_path = {0, piano_brace_data, 92};

#define LILYPOND_TEXT_EDITOR "LilyPond text editor"

static void prefix_edit_callback(GtkWidget *widget, GtkWidget *frame);
static void create_element(GtkWidget *vbox, GtkWidget *widget, gchar *lilypond);
static void create_standard_scoreblock(DenemoScoreblock **psb, gint movement, gchar *partname);
static void recreate_standard_scoreblock(DenemoScoreblock **psb);
static DenemoScoreblock *get_standard_scoreblock(GtkWidget *widget);
void refresh_lilypond(DenemoScoreblock *sb);


static gint layout_sync;


// Reverses (reflects) bits in a 32-bit word.
static guint32 bit_reverse(guint32 x) {
   x = ((x & 0x55555555) <<  1) | ((x >>  1) & 0x55555555);
   x = ((x & 0x33333333) <<  2) | ((x >>  2) & 0x33333333);
   x = ((x & 0x0F0F0F0F) <<  4) | ((x >>  4) & 0x0F0F0F0F);
   x = (x << 24) | ((x & 0xFF00) << 8) |
       ((x >> 8) & 0xFF00) | (x >> 24);
   return x;
}

/* This is the basic CRC algorithm with no optimizations. It follows the
logic circuit as closely as possible. */
//returns a 32 bit crc for the passed string
static guint32 crc32(guchar *message) {
   int i, j;
   guint32 byte, crc;
   i = 0;
   crc = 0xFFFFFFFF;
   while (message[i] != 0) {
      byte = message[i];            // Get next byte.
      byte = bit_reverse(byte);         // 32-bit reversal.
      for (j = 0; j <= 7; j++) {    // Do eight times.
         if ((int)(crc ^ byte) < 0)
              crc = (crc << 1) ^ 0x04C11DB7;
         else crc = crc << 1;
         byte = byte << 1;          // Ready next msg bit.
      }
      i = i + 1;
   }
   return bit_reverse(~crc);
}

static guint get_location(guint movementnum, guint voicecount) {
	return (movementnum<<16) | voicecount;
}
static void navigate_to_location(GtkWidget *w, guint location) {
	guint movementnum = location>>16;
	guint staffnum = location & 0xFFFF;
	goto_movement_staff_obj (NULL, movementnum, staffnum, 1, 0);
}

static popup_staff_groups_menu(GtkWidget *button) { 
	GtkWidget *menuitem = gtk_ui_manager_get_widget (Denemo.ui_manager, "/ObjectMenu/StaffMenu/StaffGroupings");
	if(get_standard_scoreblock(button)) {
	if(menuitem)
		gtk_menu_popup (GTK_MENU(gtk_menu_item_get_submenu(GTK_MENU_ITEM(menuitem)) ), NULL, NULL, NULL, NULL, 0,  GDK_CURRENT_TIME);
	else g_warning("No such menu path");
	g_print("popped\n");
	} else warningdialog("This button is for changing the score itself, it will not affect this custom layout");
}

static void staff_groups_menu(GtkWidget *w, GdkEvent *event, guint location) {
	navigate_to_location(NULL, location);
	popup_staff_groups_menu(w);
}

//callback on destroying widgets that are on the staff_list of a scoreblock.
static gboolean remove_from_staff_list(GtkWidget *widget, GList **g) {
*g = g_list_remove(*g, widget);
return TRUE; //that is go on to destroy the widget
}
//free the passed DenemoScoreblock structure for re-use or disposal
static void free_scoreblock (DenemoScoreblock *sb) {
	if(sb->widget)
		gtk_widget_destroy(sb->widget);//FIXME free lilypond attached to widgets
	sb->widget=0;
	if(sb->lilypond)
		g_string_free((GString*)(sb->lilypond), TRUE);
	sb->lilypond = NULL;
}

void  free_scoreblocks(DenemoGUI *gui) {
  if(gui->standard_scoreblocks) {
    GList *g;
    for(g=gui->standard_scoreblocks;g;g=g->next) {
			DenemoScoreblock *sb = ((DenemoScoreblock*)g->data);
      free_scoreblock(sb);
    }
    g_list_free(gui->standard_scoreblocks);
    gui->standard_scoreblocks=NULL;
  }
    if(gui->custom_scoreblocks) {
    GList *g;
    for(g=gui->custom_scoreblocks;g;g=g->next) {
			DenemoScoreblock *sb = ((DenemoScoreblock*)g->data);
      free_scoreblock(sb);
    }
    g_list_free(gui->custom_scoreblocks);
    gui->custom_scoreblocks=NULL;
  }
}



static gboolean is_in_standard_scoreblock(DenemoScoreblock *sb){
	return (g_list_find(Denemo.gui->standard_scoreblocks, sb)!=NULL);
}


static gboolean free_prefix_and_postfix(GtkWidget *widget) {
		// glib 2.28 and greater can use:
	//g_list_free_full(g_object_get_data(G_OBJECT(widget), "prefix"), (GDestroyNotify)g_free);
	//g_list_free_full(g_object_get_data(G_OBJECT(widget), "postfix"), (GDestroyNotify)g_free);
	GList *g = g_object_get_data(G_OBJECT(widget), "prefix");
	g_list_foreach(g, (GFunc)(g_free), NULL);
	g_list_free(g);
	g = g_object_get_data(G_OBJECT(widget), "postfix");
	g_list_foreach(g, (GFunc)(g_free), NULL);
  g_list_free(g);
return TRUE; //and destroy widget
}

// attaches the two lilypond strings to the prefix and postfix lists of widget
// prefix is created in the reverse order to postfix so they can nest
// the destroy widget is arranged to free the lists
static void add_lilypond(GtkWidget *w, gchar *prefix, gchar *postfix) {
	if(g_object_get_data(G_OBJECT(w), "prefix")==NULL && g_object_get_data(G_OBJECT(w), "postfix")==NULL)
		g_signal_connect(G_OBJECT(w), "destroy", G_CALLBACK(free_prefix_and_postfix), NULL);
		
	if(prefix)
		g_object_set_data(G_OBJECT(w), "prefix", (gpointer)g_list_append(g_object_get_data(G_OBJECT(w), "prefix"), prefix));
	if(postfix)
		g_object_set_data(G_OBJECT(w), "postfix", (gpointer)g_list_prepend(g_object_get_data(G_OBJECT(w), "postfix"), postfix));
}

static gchar *get_voicetag(gint movementnum, gint voice_count) {
	  GString *str = g_string_new("");
    GString *name = g_string_new("");
    g_string_printf(str, "Voice%d Mvmnt%d", voice_count, movementnum);
    set_lily_name (str, name);
    g_string_free(str, TRUE);
		return g_string_free(name, FALSE);
}
static gchar *get_voicename(gint movementnum, gint voice_count) {
	  GString *str = g_string_new("");
    GString *name = g_string_new("");
    g_string_printf(str, "Mvmnt%d Voice%d", movementnum, voice_count);
    set_lily_name (str, name);
    g_string_free(str, TRUE);
		return g_string_free(name, FALSE);
}


static gchar *get_versename(gint movementnum, gint voice_count, gint versenum) {
	  GString *str = g_string_new("");
    GString *name = g_string_new("");
    g_string_printf(str, "Mvmnt%d Voice%d Verse%d", movementnum, voice_count, versenum);
    set_lily_name (str, name);
    g_string_free(str, TRUE);
		return g_string_free(name, FALSE);
}

//Change the name of the scoreblock to user given value
static gboolean name_scoreblock(DenemoScoreblock *sb, gchar * name) {
	gchar *value;
  if(name==NULL)
		value = string_dialog_entry (Denemo.gui, "New Score Layout", "Give a name for this new score layout", "Custom Layout");
	else
		value = name;
	if(value) {
		gtk_notebook_set_tab_label_text (GTK_NOTEBOOK(get_score_layout_notebook(Denemo.gui)), sb->widget, value);
		//FIXME if name==NULL g_free(value) I think.
		return TRUE;
	} else
	return FALSE;
}

//gets the toplevel standard DenemoScoreblock which contains the passed in widget, or NULL if not in the standard scoreblocks
static DenemoScoreblock *get_standard_scoreblock(GtkWidget *widget) {
	GList *g;
	for(g=Denemo.gui->standard_scoreblocks;g;g=g->next) {
		DenemoScoreblock *sb =  (DenemoScoreblock *)g->data;
		if(sb->widget && gtk_widget_is_ancestor (widget,sb->widget))
			return sb;
	}
	return NULL;
}
//gets the toplevel custom DenemoScoreblock which contains the passed in widget, or NULL if not in the custom scoreblocks
static DenemoScoreblock *get_custom_scoreblock(GtkWidget *widget)  {
	GList *g;
	for(g=Denemo.gui->custom_scoreblocks;g;g=g->next) {
		DenemoScoreblock *sb =  (DenemoScoreblock *)g->data;
		if(sb->widget && gtk_widget_is_ancestor (widget,sb->widget))
			return sb;
	}
	return NULL;
}

static gboolean is_lilypond_text_layout(DenemoScoreblock *sb) {
return sb->widget && GTK_IS_FRAME(sb->widget) && gtk_frame_get_label(GTK_FRAME(sb->widget)) && !strcmp(gtk_frame_get_label(GTK_FRAME(sb->widget)), LILYPOND_TEXT_EDITOR);
}

 
static void convert_to_lilypond_callback(GtkWidget *widget, DenemoScoreblock *sb) {
				refresh_lilypond(sb);
				DenemoScoreblock *newsb = get_scoreblock_for_lilypond(sb->lilypond->str);
				Denemo.gui->custom_scoreblocks = g_list_remove(Denemo.gui->custom_scoreblocks, sb);
				GtkWidget *notebook = get_score_layout_notebook(Denemo.gui);
				GtkWidget *label = gtk_label_new(sb->name);
				gtk_widget_destroy(sb->widget);
				gtk_widget_show_all(newsb->widget);
				gtk_notebook_prepend_page(GTK_NOTEBOOK(notebook), newsb->widget, label);
				gtk_notebook_set_current_page (GTK_NOTEBOOK(notebook), 0);
				Denemo.gui->custom_scoreblocks = g_list_append(Denemo.gui->custom_scoreblocks, newsb);
}

static void delete_custom_scoreblock_callback(GtkWidget *widget, DenemoScoreblock *sb) {
	Denemo.gui->custom_scoreblocks = g_list_remove(Denemo.gui->custom_scoreblocks, sb);
	gtk_widget_destroy(sb->widget);
}
static void recreate_standard_scoreblock_callback(GtkWidget *widget, DenemoScoreblock **psb) {
	recreate_standard_scoreblock (psb);
}

static gboolean customize_scoreblock(DenemoScoreblock *sb, gchar *name) {
	if(name_scoreblock(sb, name)) {
		g_free(sb->partname);
		sb->partname = NULL;
		sb->movement = 0;
		if(sb->lilypond)
			g_string_free(sb->lilypond, TRUE);
		sb->lilypond = NULL;
		Denemo.gui->standard_scoreblocks = g_list_remove(Denemo.gui->standard_scoreblocks, sb);
		Denemo.gui->custom_scoreblocks = g_list_append(Denemo.gui->custom_scoreblocks, sb);
		return TRUE;
	} else
	return FALSE;
}
/* go through the layout deleting score block elements that are marked standard as they are not needed for a custom scoreblock*/
static void prune_layout(GtkWidget *layout) {
	if(GTK_IS_CONTAINER(layout)) {
		GList *g = gtk_container_get_children(GTK_CONTAINER(layout));
		if(g)
		do {
			prune_layout(g->data);
		} while ((g=g->next));
	}
	if(g_object_get_data(G_OBJECT(layout), "standard"))
		gtk_widget_destroy(layout);
}

static gboolean clone_scoreblock(DenemoScoreblock *sb, gchar *name) {
		gint movement = sb->movement;
		gchar *partname = g_strdup(sb->partname);
		prune_layout(sb->widget);
		if(customize_scoreblock(sb, name)) {
			DenemoScoreblock *newsb = g_malloc0(sizeof(DenemoScoreblock));
			create_standard_scoreblock(&newsb, movement, partname);
			Denemo.gui->standard_scoreblocks = g_list_prepend(Denemo.gui->standard_scoreblocks, newsb);
			return TRUE;
		} else {
		g_free(partname);
		return FALSE;
		}
}

static void customize_standard_scoreblock_callback(GtkWidget *widget, DenemoScoreblock *sb) {
	clone_scoreblock (sb, NULL);
}

//static gboolean options_for_layout(GtkWidget *widget, GdkEvent *event, DenemoScoreblock *sb) {
static gboolean options_for_layout(GtkWidget *widget, DenemoScoreblock *sb) {
	GtkWidget *menu = gtk_menu_new();
	GtkWidget *menuitem;
	menuitem = gtk_menu_item_new_with_label("Typeset");
	gtk_widget_set_tooltip_text(menuitem, "Typesets the current layout ready for printing to PDF file or printer");
	gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
	g_signal_connect(menuitem, "activate", G_CALLBACK(show_print_view), NULL);
	if(g_list_find(Denemo.gui->custom_scoreblocks, sb)) {
		if(!is_lilypond_text_layout(sb)) {
			menuitem = gtk_menu_item_new_with_label("Convert to LilyPond text");
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
			g_signal_connect(menuitem, "activate", G_CALLBACK(convert_to_lilypond_callback), sb);
		}
		
		menuitem = gtk_menu_item_new_with_label("Delete");
		gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
		g_signal_connect(menuitem, "activate", G_CALLBACK(delete_custom_scoreblock_callback), sb);
	} else {
		GList *g = g_list_find(Denemo.gui->standard_scoreblocks, sb);
		if(g) {
			menuitem = gtk_menu_item_new_with_label("Refresh");
			gtk_widget_set_tooltip_text(menuitem, "Re-calculates this layout from the Denemo score - do this after structural changes to the score.");
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
			g_signal_connect(menuitem, "activate", G_CALLBACK(recreate_standard_scoreblock_callback), &(g->data));
			menuitem = gtk_menu_item_new_with_label("Customize");
			gtk_widget_set_tooltip_text(menuitem, "Create a layout from this standard layout that you can then modify.");
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
			g_signal_connect(menuitem, "activate", G_CALLBACK(customize_standard_scoreblock_callback), sb);
		}
	}

	gtk_widget_show_all(menu);
	gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, 0, GDK_CURRENT_TIME);
	return TRUE;
}
static GtkWidget *get_options_button(DenemoScoreblock *sb) {
	GtkWidget *menubar = gtk_menu_bar_new();
	GtkWidget *menuitem = gtk_menu_item_new_with_label("Options for this Layout");
	gtk_widget_set_tooltip_text (menuitem,"Double Click here to get a menu: typeset this layout, or re-compute the layout after changing the score structurally,\nor  create a customized layout or delete one");
	gtk_menu_shell_append(menubar, menuitem);
	g_signal_connect(menuitem, "activate", G_CALLBACK(options_for_layout), sb);
	return menubar;	
}



//if widget is in a standard scoreblock, clone the scoreblock converting the standard one into a custom one.
static gboolean clone_scoreblock_if_needed(GtkWidget *widget) {
	DenemoScoreblock *default_sb;
	if((default_sb=get_standard_scoreblock(widget))) {
		//the button widget was on the default scoreblock, so we convert this to a custom scoreblock
		//and create a new default scoreblock
		return clone_scoreblock(default_sb, NULL);
	}
	return TRUE;
}


static gboolean move_parent(GtkWidget *widget, gboolean up) {
	if(!clone_scoreblock_if_needed(widget)) return TRUE;

	GtkWidget *parent = gtk_widget_get_parent(widget);
	GtkWidget *grandparent = gtk_widget_get_parent(parent);
	GList *children = gtk_container_get_children(GTK_CONTAINER(grandparent));
	gint position = g_list_index(children, parent);
	if(up) {
		if(position>0) {
			position--;
			gtk_box_reorder_child(GTK_BOX(grandparent), parent, position);
			score_status(Denemo.gui, TRUE);
		}
	} else {
		position++;
		gtk_box_reorder_child(GTK_BOX(grandparent), parent, position);
		score_status(Denemo.gui, TRUE);
	}	
return TRUE;
}


static gboolean move_grandparent(GtkWidget *widget, gboolean up) {
	if(!clone_scoreblock_if_needed(widget)) return TRUE;

	GtkWidget *parent = gtk_widget_get_parent(gtk_widget_get_parent(widget));
	GtkWidget *grandparent = gtk_widget_get_parent(parent);
	GList *children = gtk_container_get_children(GTK_CONTAINER(grandparent));
	gint position = g_list_index(children, parent);
	if(up) {
	if(position>0) {
		position--;
		gtk_box_reorder_child(GTK_BOX(grandparent), parent, position);
		score_status(Denemo.gui, TRUE);
	}
	} else {
		position++;
		gtk_box_reorder_child(GTK_BOX(grandparent), parent, position);
		score_status(Denemo.gui, TRUE);
	}
return TRUE;
}


static gboolean remove_element(GtkWidget *widget) {
	if(!clone_scoreblock_if_needed(widget)) return TRUE;

	GtkWidget *parent = gtk_widget_get_parent(widget);
	gtk_widget_destroy(parent);
	score_status(Denemo.gui, TRUE);
return TRUE;
}

static gboolean remove_parent_element(GtkWidget *widget) {
	if(!clone_scoreblock_if_needed(widget)) return TRUE;
	GtkWidget *parent = gtk_widget_get_parent(gtk_widget_get_parent(widget));
	gtk_widget_destroy(parent);
	score_status(Denemo.gui, TRUE);
return TRUE;
}

static gboolean remove_lyric_element(GtkWidget *widget, gchar *context_text) {
	if(!clone_scoreblock_if_needed(widget)) return TRUE;
	GtkWidget *parent = gtk_widget_get_parent(widget);
	GtkWidget *grandparent = gtk_widget_get_parent(parent);
	gtk_widget_destroy(parent);
	GList *postfixes = (GList*)g_object_get_data(G_OBJECT(grandparent), "postfix");
	g_object_set_data(G_OBJECT(grandparent), "postfix", (gpointer)g_list_remove(postfixes, context_text));
	//free context_text here
	score_status(Denemo.gui, TRUE);
	return TRUE;
}





static GtkWidget *create_voice_widget(DenemoStaff *staff, gchar *voicename, guint location) {
	gchar *name = staff->denemo_name->str;
	GtkWidget *ret = gtk_hbox_new(FALSE, 8);
			
	GtkWidget *w = gtk_button_new_with_label("X");
	gtk_widget_set_tooltip_text (w,"Delete this element from the score layout");
	g_signal_connect(w, "clicked", G_CALLBACK(remove_element), NULL);
	gtk_box_pack_end(GTK_BOX (ret), w, FALSE, TRUE, 0);

	gchar *text = g_strdup_printf(" \\%s",  voicename);
	if(staff->voicecontrol==DENEMO_PRIMARY) {
	GtkWidget *expander = gtk_expander_new("Initial Signatures");
	gtk_widget_set_tooltip_text(expander, "Click here to view and edit the clef, key and time signatures of this staff");
	gtk_box_pack_start(GTK_BOX(ret), expander, FALSE, TRUE, 0);
	GtkWidget *hbox = gtk_hbox_new(FALSE, 8);
	gtk_container_add (GTK_CONTAINER (expander), hbox);

	GtkWidget *button = gtk_button_new_with_label(_("Clef"));
	gtk_widget_set_tooltip_text(button, "Edit the LilyPond definition of the clef. The editing affects only this layout.");
	g_signal_connect(G_OBJECT(button), "clicked", G_CALLBACK(prefix_edit_callback), button);
	add_lilypond(button,  get_clef_string(staff), NULL);
	gtk_box_pack_start(GTK_BOX (hbox), button, FALSE, TRUE, 0);

	button = gtk_button_new_with_label(_("Key"));
	gtk_widget_set_tooltip_text(button, "Edit the LilyPond definition of the key signature. The editing affects only this layout.");
	g_signal_connect(G_OBJECT(button), "clicked", G_CALLBACK(prefix_edit_callback), button);
	add_lilypond(button,  get_key_sig_string(staff), NULL);
	gtk_box_pack_start(GTK_BOX (hbox), button, FALSE, TRUE, 0);

	button = gtk_button_new_with_label(_("Time"));
	gtk_widget_set_tooltip_text(button, "Edit the LilyPond definition of the time signature. The editing affects only this layout.");
	g_signal_connect(G_OBJECT(button), "clicked", G_CALLBACK(prefix_edit_callback), button);
	add_lilypond(button,  get_time_sig_string(staff), NULL);
	gtk_box_pack_start(GTK_BOX (hbox), button, FALSE, TRUE, 0);
	}
	gchar *music = g_strconcat("Music for ", name, NULL);
	w = gtk_button_new_with_label(music);
	gtk_widget_set_tooltip_text(w, "The actual notes live here. You can only edit these in the main Denemo display.\nHowever you can place conditional directives that are to be used only when using this layout. For example page breaks just for this layout can be placed at points in the music.\nClick here to move the Denemo cursor to the start of this music.");
	g_signal_connect(G_OBJECT(w), "clicked", G_CALLBACK(navigate_to_location), (gpointer)location);
	g_free(music);
	add_lilypond(w, text, NULL);
	gtk_box_pack_start(GTK_BOX (ret), w, FALSE, TRUE, 0);

	return ret;
	
}

static GtkWidget *create_lyric_widget(gchar *context_text, gchar *name) {
		GtkWidget *ret = gtk_hbox_new(FALSE, 8);
	
	GtkWidget *w = gtk_button_new_with_label("X");
	gtk_widget_set_tooltip_text (w,"Drop this lyric part from the score layout");
	g_signal_connect(w, "clicked", G_CALLBACK(remove_lyric_element), context_text);
	gtk_box_pack_end(GTK_BOX (ret), w, FALSE, TRUE, 0);
	w = gtk_button_new_with_label(name);
	//FIXME pop up the lyrics here or some info, or navigate??
	gtk_box_pack_start(GTK_BOX (ret), w, FALSE, TRUE, 0);

	w = gtk_button_new_with_label("‚¨Ü");
	gtk_widget_set_tooltip_text (w,"Move this lyric part above the staff for this score layout");
	gtk_box_pack_start(GTK_BOX (ret), w, FALSE, TRUE, 0);
	g_signal_connect(w, "clicked", G_CALLBACK(move_parent), (gpointer)TRUE);
	w = gtk_button_new_with_label("‚¨á");
	gtk_widget_set_tooltip_text (w,"Move this lyric part below the staff for this score layout");
	gtk_box_pack_start(GTK_BOX (ret), w, FALSE, TRUE, 0);
	g_signal_connect(w, "clicked", G_CALLBACK(move_parent), (gpointer)FALSE);
	return ret;
}

static void install_voice(DenemoStaff *staff, gint movementnum, gint voice_count, GtkWidget *vbox) {
	
		gchar *voicetag = get_voicetag(movementnum, voice_count);
		gchar *voicename = get_voicename(movementnum, voice_count);
		GtkWidget *voice = create_voice_widget(staff, voicename, get_location(movementnum, voice_count));

		GString *voicetext = g_string_new("");
		set_voice_definition(voicetext, staff, voicetag);//That is \new Voice = name prefix { postfix FIXME is prefix any use here????
		gchar *text = g_strdup_printf(" %s ",  voicetext->str);
		g_string_assign(voicetext, "");
		set_voice_termination(voicetext, staff); // TAB TAB"} %End of voice" if not overridden
		add_lilypond(voice, text, g_string_free(voicetext, FALSE));
		
		gtk_box_pack_start (GTK_BOX (vbox), voice, FALSE, TRUE, 0);
}

static void do_verses(DenemoStaff *staff, GtkWidget *vbox, gint movementnum, gint voice_count) {
	
			//FIXME do text of the verses get_text_from_view(GtkWidget *textview) where staff->verses->data is textview widget
			GList *g = staff->verses;
			gint versenum = 1;
			for(versenum=1;g;g=g->next, versenum++) {
				gchar *versename = get_versename(movementnum, voice_count, versenum);
				gchar *context_text = g_strdup_printf("\n"TAB"\\%s%s", versename, "Context\n");
				//gchar *label = g_strconcat("Lyrics:", staff->denemo_name->str, NULL);
				gchar *label = g_strdup_printf("Verse %d: %s", versenum, staff->denemo_name->str);
				GtkWidget *voice = create_lyric_widget(context_text, label);
				g_free(label);
				gchar *lyrics = g_strdup_printf("\n"TAB"\\new Lyrics = %s\n", versename /*e.g. MvmntIVoiceIVerseI*/);
				add_lilypond(voice, lyrics, NULL);	//FIXME the destroy of these widgets should free the string	
			
				gtk_box_pack_start (GTK_BOX (vbox), voice, FALSE, TRUE, 0);//has to go outside the staff
				add_lilypond (vbox, NULL, context_text);
			
				g_free(versename);
			}
		
}


//if oldval is in the prefix list attached to widget, replace it with newval and free oldval
static gboolean edit_lilypond_prefix(GtkWidget *widget, gchar *oldval, gchar *newval) {
GList *g;
for(g=g_object_get_data(G_OBJECT(widget), "prefix");g;g=g->next)
	if(!strcmp((gchar*)g->data, oldval)) {
		g->data = (gpointer)newval;
		g_free(oldval);
		return TRUE;
	}
return FALSE;
}


static void prefix_edit_callback(GtkWidget *widget, GtkWidget *frame) {
	if(!clone_scoreblock_if_needed(frame)) return;
	GList *g = g_object_get_data(G_OBJECT(frame), "prefix");
	if(g) {
			gchar *lily = (gchar*)g->data;
			gchar *newval = string_dialog_editor_with_widget (Denemo.gui, "Edit LilyPond", "Edit this using LilyPond syntax\nThe editing applies just to this score layout", lily?lily:"", NULL);
			if(newval) {
				edit_lilypond_prefix(frame, lily, newval);
				score_status(Denemo.gui, TRUE);
			}
	}
}

static void affixes_delete_callback(GtkWidget *widget, GtkWidget *frame) {
	if(!clone_scoreblock_if_needed(frame)) return;
	GList *g = g_object_get_data(G_OBJECT(frame), "prefix");
	if(g) g_free(g->data);
	g_object_set_data(G_OBJECT(frame), "prefix", NULL);
	g = g_object_get_data(G_OBJECT(frame), "postfix");
	if(g) g_free(g->data);
	g_object_set_data(G_OBJECT(frame), "postfix", NULL);
	gtk_frame_set_label_widget(GTK_FRAME(frame), NULL);
	
	score_status(Denemo.gui, TRUE);
}


static gboolean popup(GtkWidget *button, GtkWidget *menu) {
	gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, 0, GDK_CURRENT_TIME);
return FALSE;
}

static void create_element(GtkWidget *vbox, GtkWidget *widget, gchar *lilypond) {
			GtkWidget *hbox = gtk_hbox_new(FALSE, 8);
			gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);
			add_lilypond(hbox, lilypond, NULL);
			gtk_box_pack_start(GTK_BOX(hbox), widget, FALSE, TRUE, 0);
			GtkWidget *button = gtk_button_new_with_label("Edit");
			gtk_widget_set_tooltip_text (button,"Edit this element for this layout");	
			gtk_box_pack_start(GTK_BOX (hbox), button, FALSE, TRUE, 0);
			g_signal_connect(button, "clicked", G_CALLBACK(prefix_edit_callback), hbox);
			button = gtk_button_new_with_label("‚¨Ü");
			gtk_widget_set_tooltip_text (button,"Move this element upwards for this score layout");
			gtk_box_pack_start(GTK_BOX (hbox), button, FALSE, TRUE, 0);
			g_signal_connect(button, "clicked", G_CALLBACK(move_parent), (gpointer)TRUE);
			button = gtk_button_new_with_label("‚¨á");
			gtk_widget_set_tooltip_text (button,"Move this element downwards for this score layout");
			gtk_box_pack_start(GTK_BOX (hbox), button, FALSE, TRUE, 0);
			g_signal_connect(button, "clicked", G_CALLBACK(move_parent), (gpointer)FALSE);
			button = gtk_button_new_with_label("X");
			gtk_widget_set_tooltip_text (button,"Remove this element from this layout");
			gtk_box_pack_end(GTK_BOX (hbox), button, FALSE, TRUE, 0);
			g_signal_connect(button, "clicked", G_CALLBACK(remove_element), NULL);
			gtk_widget_show_all(hbox);
}



//gtk_expander_set_expanded (expander,gtk_expander_get_expanded (expander));
static void toggle_expand (GtkWidget *item, GtkWidget *expander) {
	gtk_expander_set_expanded (GTK_EXPANDER(expander), !gtk_expander_get_expanded (GTK_EXPANDER(expander)));
}


static void page_break(GtkWidget *item,  GtkWidget *vbox) {
	if(!clone_scoreblock_if_needed(vbox)) return;
	GtkWidget *button = gtk_button_new_with_label("Page Break");
	gtk_widget_set_tooltip_text (button,"This forces a new page, useful for avoiding page turns\nMove it before the title!");
	create_element(vbox, button, g_strdup("\\pageBreak\n"));
	score_status(Denemo.gui, TRUE);
}
static void blank_page(GtkWidget *item,  GtkWidget *vbox) {
	if(!clone_scoreblock_if_needed(vbox)) return;
	GtkWidget *button = gtk_button_new_with_label("Blank Page");
	gtk_widget_set_tooltip_text (button,"This prints a page intentionally left blank, useful for avoiding page turns\nMove it before the title!");
	create_element(vbox, button, g_strdup("\\pageBreak\n\\markup \\italic \"This page is intentionally left blank\"\n\\pageBreak\n"));
	score_status(Denemo.gui, TRUE);
}
static void custom_lilypond(GtkWidget *item,  GtkWidget *vbox) {
	if(!clone_scoreblock_if_needed(vbox)) return;
	GtkWidget *button = gtk_button_new_with_label("Lilypond");
	gtk_widget_set_tooltip_text (button,"This lets you insert your own titles etc just for this layout.\nFor book titles use \\titledPiece \\markup \"myname\"\nSimple titles are not placed here, but appear in a header block at the end of the movement.\nFor other possible uses, see LilyPond manual.");
	create_element(vbox, button, g_strdup("%Enter LilyPond syntax here\n"));
	score_status(Denemo.gui, TRUE);
}

static GtkWidget *get_titles_menu(GtkWidget *vbox) {
	GtkWidget *menu = gtk_menu_new();
	GtkWidget *item;

	item = gtk_menu_item_new_with_label("Create Page Break");
	gtk_widget_set_tooltip_text (item,"This inserts a page break, useful for avoiding page turns\nMove it before the title!");
	g_signal_connect(item, "activate", G_CALLBACK(page_break), vbox);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);

	item = gtk_menu_item_new_with_label("Create Blank Page");
	gtk_widget_set_tooltip_text (item,"This inserts a page intentionally left blank, useful for avoiding page turns when printing on both sides of the paper");
	g_signal_connect(item, "activate", G_CALLBACK(blank_page), vbox);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);

	item = gtk_menu_item_new_with_label("Insert LilyPond");
	gtk_widget_set_tooltip_text (item,"This lets you insert your own titles etc just for this layout.");
	g_signal_connect(item, "activate", G_CALLBACK(custom_lilypond), vbox);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);

	item =gtk_separator_menu_item_new ();
	gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);

	gtk_widget_show_all(menu);
	return menu;
}
static void titles_menu_callback (GtkWidget *expander, GtkWidget *menu) {
	g_signal_stop_emission_by_name (expander, "activate");//this callback does not allow you to omit the default handler, this does that
	gtk_expander_set_expanded (GTK_EXPANDER(expander), TRUE);
	gtk_menu_popup (GTK_MENU(menu), NULL, NULL, NULL, NULL, 0,  GDK_CURRENT_TIME);	
}

//return a newly allocated label to hint at the contents of a directive
static gchar *label_for_directive(DenemoDirective *d) {
					gchar *text = g_strdup_printf("%s%s%.25s",	d->tag?d->tag->str:"<Unknown Tag>", d->display?": ":"", d->display?d->display->str:"");
					gchar *etext = g_strescape(text, NULL);
					g_free(text);
					return etext;
}

static popup_movement_menu(GtkWidget *w, GtkWidget *vbox) {
gtk_menu_popup (GTK_MENU(get_titles_menu(vbox)), NULL, NULL, NULL, NULL, 0,  GDK_CURRENT_TIME);	
}
/* installs movement titles, page breaks etc
 *
 */
static void install_pre_movement_widgets(GtkWidget *vbox, DenemoScore *si) {
		GtkWidget *frame = gtk_frame_new(NULL);
		gtk_box_pack_start(GTK_BOX(vbox), frame, FALSE, TRUE, 0);
		GtkWidget *expander = gtk_expander_new("Movement Titles etc");
		gtk_widget_set_tooltip_text(expander, "In here are settings for the movement title, page breaks before the movement etc");
		gtk_container_add (GTK_CONTAINER (frame), expander);
		
		GtkWidget *inner_vbox = gtk_vbox_new(FALSE, 8);
		//g_signal_connect(G_OBJECT(expander), "activate", G_CALLBACK(titles_menu_callback), get_titles_menu(expander, inner_vbox));
		gtk_container_add (GTK_CONTAINER (expander), inner_vbox);
		
		GtkWidget *button = gtk_button_new_with_label("Create for Custom Layout");
		gtk_widget_set_tooltip_text(button, _("Create page breaks, blank pages ...for this layout"));
		g_signal_connect(button, "clicked", G_CALLBACK(popup_movement_menu), inner_vbox);
		gtk_box_pack_start(GTK_BOX(inner_vbox), button, FALSE, TRUE, 0);
		
		GList *g;
		for(g=si->movementcontrol.directives;g;g=g->next) {
			DenemoDirective *d=(DenemoDirective*)g->data;
			if(d->override&DENEMO_OVERRIDE_AFFIX)
				continue;
			if(d->override&DENEMO_OVERRIDE_HIDDEN)
				continue;
			gchar * text = label_for_directive(d);
			
			GtkWidget *label = gtk_label_new(text);
			g_free(text);
			create_element(inner_vbox, label, g_strdup(d->prefix->str));		
		}
}

static popup_score_menu(GtkWidget *button) { 
	GtkWidget *menuitem = gtk_ui_manager_get_widget (Denemo.ui_manager, "/ObjectMenu/Score/Titles/Book Titles");
	if(get_standard_scoreblock(button)) {
	if(menuitem)
		gtk_menu_popup (GTK_MENU(gtk_menu_item_get_submenu(GTK_MENU_ITEM(menuitem)) ), NULL, NULL, NULL, NULL, 0,  GDK_CURRENT_TIME);
	else g_warning("No such menu path");
	} else warningdialog("This button is for changing the score itself, it will not affect this custom layout");
}


/* install widgets for the score directives.
 * 
 */
static GtkWidget *install_scoreblock_overrides(GtkWidget *vbox, DenemoGUI *gui, DenemoScore *si, gboolean last_movement) {

	GList *g;
	 for(g=gui->lilycontrol.directives;g;g=g->next) {
    DenemoDirective *d = g->data;
    if(d->override & DENEMO_OVERRIDE_HIDDEN)
			continue;
		if(d->override & DENEMO_OVERRIDE_AFFIX)
			continue;
		gchar *start = (d->postfix && d->postfix->len)?d->postfix->str:NULL;
		if(start) {
			GtkWidget *frame = gtk_frame_new(NULL);

			gchar * text = label_for_directive(d);	
			GtkWidget *button = gtk_button_new_with_label(text);
			g_free(text);
			gtk_frame_set_label_widget (GTK_FRAME(frame), button);
			gtk_box_pack_start(GTK_BOX(vbox), frame, FALSE, TRUE, 0);
			gchar *lily = g_strdup_printf("\n<< %s\n<< ", start);
			add_lilypond(frame, lily, g_strdup("\n>>\n>>"));

			GtkWidget *menu = gtk_menu_new();
			GtkWidget *menuitem = gtk_menu_item_new_with_label("Edit");
			g_signal_connect(menuitem, "activate", G_CALLBACK(prefix_edit_callback), frame);
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
			menuitem = gtk_menu_item_new_with_label("Delete");
			g_signal_connect(menuitem, "activate", G_CALLBACK(affixes_delete_callback), frame);
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
			gtk_widget_show_all(menu);
			g_signal_connect(button, "clicked", G_CALLBACK(popup), menu);
	

			
			vbox = gtk_vbox_new(FALSE, 8);
			gtk_container_add(GTK_CONTAINER(frame), vbox);
			}
		}
	return vbox;
}


static draw_staff_brace(GtkWidget *w, GdkEventExpose *event, gchar *context) {
	GtkAllocation allocation;
	gtk_widget_get_allocation (w, &allocation);
	gint width = allocation.width, height = allocation.height;
	cairo_t *cr = gdk_cairo_create (event->window);
  gdk_cairo_region (cr, event->region);
  cairo_clip (cr);
  cairo_set_source_rgb (cr, 0.9, 0.9, 0.9);
  cairo_paint (cr);
	
	cairo_set_source_rgb (cr, 0, 0, 0);
	if((!strcmp(context, "ContextChoirStaff"))||(!strcmp(context, "ContextGroupStaff"))) {
		drawfetachar_cr (cr, 0xD8, 5.0, 8.0);
		cairo_rectangle (cr, 5.0, 10.0, 3, height - 22.0);
		cairo_fill(cr);
		cairo_rectangle (cr, 10.0, 9.0, 1, height - 21.0);
		cairo_fill(cr);
		drawfetachar_cr (cr, 0xD9, 5.0, height - 15.0);
	} else {
		cairo_translate (cr, 0, 10.0);
		cairo_scale (cr, 1.0, height/110.0);
		cairo_append_path (cr, &piano_brace_path);
		cairo_fill(cr);
	}
  cairo_destroy(cr);
  return TRUE;
}
static gboolean remove_context(GtkWidget *button, GtkWidget *parent) {
	if(!clone_scoreblock_if_needed(parent)) return TRUE;
	GList *children = gtk_container_get_children(GTK_CONTAINER(parent));
	gtk_widget_reparent(g_list_last(children)->data, gtk_widget_get_parent(gtk_widget_get_parent(parent)));
	gtk_widget_destroy(gtk_widget_get_parent(parent));
return TRUE;
}

//Move the frame above into this frame's vbox, unless we are inside it.
static gboolean move_context_up(GtkWidget *button, GtkWidget *parent) {
	if(!clone_scoreblock_if_needed(parent)) return TRUE;
	DenemoScoreblock *sb = get_custom_scoreblock(parent);
	gint index = g_list_index(sb->staff_list, parent);
	if(index>0) {
		GtkWidget *frame = (GtkWidget*)g_list_nth (sb->staff_list, index-1)->data;
		if(!gtk_widget_is_ancestor(parent, frame)) {
			GtkWidget *hbox = gtk_bin_get_child(GTK_BIN(parent));
			GList *children = gtk_container_get_children(GTK_CONTAINER(hbox));
			GtkWidget *vbox = g_list_last(children)->data;
			g_list_free(children);
			gtk_widget_reparent(frame, vbox);
			gtk_box_reorder_child (GTK_BOX(vbox), frame, 0);
			//now move the frame on one in the list of frames
			sb->staff_list = g_list_remove(sb->staff_list, frame);
			sb->staff_list = g_list_insert(sb->staff_list, frame, index);
			//layout = ???
		}
	}
return TRUE;
}
//Move the frame below into this frame's vbox, unless we are inside it.
static gboolean move_context_down(GtkWidget *button, GtkWidget *parent) {
	if(!clone_scoreblock_if_needed(parent)) return TRUE;
	DenemoScoreblock *sb = get_custom_scoreblock(parent);
	g_assert(sb);
	gint index = g_list_index(sb->staff_list, parent);
	if(index<g_list_length(sb->staff_list)) {
		GtkWidget *frame = (GtkWidget*)g_list_nth (sb->staff_list, index+1)->data;
		if(!gtk_widget_is_ancestor(parent, frame)) {
			GtkWidget *hbox = gtk_bin_get_child(GTK_BIN(parent));
			GList *children = gtk_container_get_children(GTK_CONTAINER(hbox));
			GtkWidget *vbox = g_list_last(children)->data;
			g_list_free(children);
			gtk_widget_reparent(frame, vbox);
			gtk_box_reorder_child (GTK_BOX(vbox), frame, -1);
			//now move the frame on one in the list of frames
			//sb->staff_list = g_list_remove(sb->staff_list, frame);
			//sb->staff_list = g_list_insert(sb->staff_list, frame, index);
//			layout_sync = ???
		}
	}
return TRUE;
}


static GtkWidget *install_staff_group_start(GList **pstaffs, GtkWidget *vbox, GList *directives, gint *nesting) {
	GList *g;
	for(g=directives;g;g=g->next) {
		DenemoDirective *directive = g->data;
		if(directive->override&DENEMO_OVERRIDE_AFFIX) {
			if(directive->prefix && (directive->prefix->len>0))
				{
				GtkWidget *frame = (GtkWidget*)gtk_frame_new(directive->tag->str);			
				add_lilypond(frame, directive->prefix?g_strdup(directive->prefix->str):NULL, directive->postfix?g_strdup(directive->postfix->str):NULL);
				(*nesting)++;
				*pstaffs = g_list_append(*pstaffs, frame);
				g_signal_connect(G_OBJECT(frame), "destroy", G_CALLBACK(remove_from_staff_list), pstaffs);
				gtk_box_pack_start(GTK_BOX (vbox), frame, FALSE, TRUE, 0);
				GtkWidget *hbox = gtk_hbox_new(FALSE, 8);
				gtk_container_add (GTK_CONTAINER (frame), hbox);
				

				GtkWidget *layout = gtk_drawing_area_new();
				
				g_signal_connect (G_OBJECT (layout), "expose_event",
		      G_CALLBACK (draw_staff_brace),directive->tag->str);

				gint width = 20, height = 100;
				gtk_widget_set_size_request(layout, width, height);

				gtk_box_pack_start(GTK_BOX (hbox), layout, TRUE, TRUE, 0);

				GtkWidget *controls = gtk_vbox_new(FALSE, 8);
				gtk_box_pack_start(GTK_BOX (hbox), controls, FALSE, TRUE, 0);

				GtkWidget *button = gtk_button_new_with_label("X");
				g_signal_connect(button, "clicked", G_CALLBACK(remove_context), hbox);
        gtk_box_pack_start(GTK_BOX (controls), button, FALSE, TRUE, 0);


        button = gtk_button_new_with_label("‚¨Ü");
				g_signal_connect(button, "clicked", G_CALLBACK(move_context_up), frame);
        gtk_box_pack_start(GTK_BOX (controls), button, FALSE, TRUE, 0);
        button = gtk_button_new_with_label("‚¨á");
				g_signal_connect(button, "clicked", G_CALLBACK(move_context_down), frame);
        gtk_box_pack_start(GTK_BOX (controls), button, FALSE, TRUE, 0);

				vbox = gtk_vbox_new(FALSE, 8);//this vbox will be passed back so that the staffs can be put inside this staff group frame.
				gtk_box_pack_end(GTK_BOX (hbox), vbox, FALSE, TRUE, 0);
				}
		}
	}
 return vbox;
}

static GtkWidget *install_staff_group_end(GtkWidget *vbox, GList *directives, gint *nesting) {
	GList *g;
	for(g=directives;g;g=g->next) {
		DenemoDirective *directive = g->data;
		if(directive->override&DENEMO_OVERRIDE_AFFIX) {
			if(directive->postfix && (directive->postfix->len>0)) {
					if(*nesting) {
						add_lilypond(gtk_widget_get_parent(vbox), NULL, g_strdup(directive->postfix->str));
						(*nesting)--;
						vbox = gtk_widget_get_parent(gtk_widget_get_parent(gtk_widget_get_parent(vbox)));
					}
					else
						g_warning("Badly placed end of staff group - ignored");									
				}
		}
	}
 return vbox;
}

static GtkWidget *get_label(GtkWidget *button) {
 if(GTK_IS_CONTAINER(button)) {
    GList *g = gtk_container_get_children (GTK_CONTAINER(button));
    for(;g;g=g->next)
      if(GTK_IS_LABEL(g->data))
				return GTK_WIDGET(g->data);
 }
	return NULL;
}

static GtkWidget *get_large_button(gchar *text) {
	GtkWidget *button = gtk_button_new_with_label("dummy");
	GtkWidget *label = get_label(button);
	gchar *markup = g_markup_printf_escaped("<big>%s</big>", text);
	gtk_label_set_markup(GTK_LABEL(label), markup);
	g_free(markup);
	return button;
}
static GtkWidget *get_small_button(gchar *text) {
	GtkWidget *button = gtk_button_new_with_label("dummy");
	GtkWidget *label = get_label(button);
	gchar *markup = g_markup_printf_escaped("<small>%s</small>", text);
	gtk_label_set_markup(GTK_LABEL(label), markup);
	g_free(markup);
	return button;
}
static void add_staff_widget(DenemoStaff *staff, GtkWidget *hbox) {
	gchar *clef_glyph = "\xF0\x9D\x84\x9E     ";
	switch(staff->clef.type){
		case DENEMO_FRENCH_CLEF:

		case DENEMO_TREBLE_CLEF: clef_glyph = "ùÑû     ";
			break;
		case DENEMO_G_8_CLEF: clef_glyph = "ùÑü  ";
			break;
			
		case DENEMO_F_8_CLEF:clef_glyph = "ùÑ§   ";
			break;

		case DENEMO_BASS_CLEF: clef_glyph = "ùÑ¢     ";
			break;
		case DENEMO_SOPRANO_CLEF:
		case DENEMO_ALTO_CLEF:
		case DENEMO_TENOR_CLEF: clef_glyph = "ùÑ°   ";
			break;
	}
	GtkWidget *button = get_large_button(clef_glyph);
	gtk_box_pack_start(GTK_BOX (hbox), button, FALSE, TRUE, 0);

	button = get_small_button("‚¨Ü");
	gtk_box_pack_start(GTK_BOX (hbox), button, FALSE, TRUE, 0);
	g_signal_connect(button, "clicked", G_CALLBACK(move_grandparent), (gpointer)TRUE);
	button = get_small_button("‚¨á");
	gtk_box_pack_start(GTK_BOX (hbox), button, FALSE, TRUE, 0);
	g_signal_connect(button, "clicked", G_CALLBACK(move_grandparent), (gpointer)FALSE);

	button = gtk_button_new_with_label("X");
	gtk_box_pack_end(GTK_BOX (hbox), button, FALSE, TRUE, 0);
	g_signal_connect(button, "clicked", G_CALLBACK(remove_parent_element), NULL);
	}

//Mark the passed widget as being for standard layouts only
static void	mark_as_non_custom(GtkWidget *button) {
	GdkColor color;
			if(gdk_color_parse ("#908070",&color))
				gtk_widget_modify_bg (button, GTK_STATE_NORMAL, &color);
	g_object_set_data(G_OBJECT(button), "standard", (gpointer)1);
}



static GtkWidget *get_movement_widget(GList **pstaffs, gchar *partname, DenemoScore *si, gint movementnum, gboolean last_movement, gboolean only_movement) {
	DenemoGUI *gui = Denemo.gui;
	gint staff_group_nesting = 0;//to check on loose staff group markers
	gint voice_count;//a count of voices from the very top of the score (ie DenemoStaffs in thescore)
	gint staff_count;//a count of staffs excluding voices from top of score
	//gchar *label_text = only_movement?NULL:g_strdup_printf("Movement %d", movementnum);
	GtkWidget *ret = gtk_frame_new(NULL);
	//g_free(label_text);


	GString *start = g_string_new("");
	set_initiate_scoreblock(si, start); // ie << possibly overridden
	
  add_lilypond(ret, g_string_free(start, FALSE), g_strdup("\n>>\n"));

	GtkWidget *vbox = gtk_vbox_new(FALSE, 8);
	gtk_container_add (GTK_CONTAINER (ret), vbox);

	vbox = install_scoreblock_overrides(vbox, gui, si, last_movement);//things like transpose whole score etc

	gchar *label_text = (si->thescore->next==NULL)?"The Staff":"The Staffs";
	GtkWidget *topexpander = gtk_expander_new(label_text);
	gtk_expander_set_expanded(GTK_EXPANDER(topexpander), si==Denemo.gui->si);
	gtk_box_pack_start (GTK_BOX (vbox), topexpander, FALSE, TRUE, 0);
	vbox = gtk_vbox_new(FALSE, 8);
	gtk_container_add (GTK_CONTAINER (topexpander), vbox);

	GList *g;
	for(voice_count = 1, staff_count = 1, g = si->thescore;g;g=g->next, voice_count++, staff_count++) {
		DenemoStaff *staff = g->data;
		DenemoStaff *nextstaff = g->next?g->next->data:NULL;
		if(partname && strcmp(partname, staff->lily_name->str))
			continue;
		if(partname==NULL) //Don't attempt staff groups for single part
			vbox = install_staff_group_start(pstaffs, vbox, staff->staff_directives, &staff_group_nesting);
	
		if(staff->hasfakechords) {//the reason these are outside the staff frame is it makes them appear above the staff
			GtkWidget *chords = gtk_label_new("chord symbols");	
			gchar *text = g_strdup_printf("\n"TAB TAB"\\new ChordNames \\chordmode { \\%sChords }\n", 
				   get_voicename(movementnum, voice_count));
			add_lilypond(chords, text, NULL);
			gtk_box_pack_start (GTK_BOX (vbox), chords, FALSE, TRUE, 0);
			*pstaffs = g_list_append(*pstaffs, chords);
			g_signal_connect(G_OBJECT(chords), "destroy", G_CALLBACK(remove_from_staff_list), pstaffs);
		}
	
		label_text = (si->thescore->next==NULL)?g_strdup("The Staff"):g_strdup_printf("Staff %d", staff_count);
		GtkWidget *frame = gtk_frame_new(NULL);

		GtkWidget *staff_hbox = gtk_hbox_new(FALSE, 8);
		gtk_frame_set_label_widget (GTK_FRAME(frame), staff_hbox);
		GtkWidget *button = gtk_button_new_with_label(label_text);
		g_free(label_text);
		gtk_box_pack_start(GTK_BOX (staff_hbox), button, FALSE, TRUE, 0);
		gtk_widget_set_tooltip_text(button, "Click to edit the properties of the staff to customize this layout\nTake care only alter the obvious bits, such as instrument name etc\nInjudicious deletion of the LilyPond typesetting characters {<<# etc can make the layout unreadable by the LilyPond typesetter. Just delete the layout if you get stuck.");

			GtkWidget *menu = gtk_menu_new();
			GtkWidget *menuitem = gtk_menu_item_new_with_label("Move Cursor Here");
			g_signal_connect(G_OBJECT(menuitem), "activate", G_CALLBACK(navigate_to_location), (gpointer)get_location(movementnum, voice_count)); 
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);

			menuitem = gtk_menu_item_new_with_label("Edit Staff Properties");
			g_signal_connect(menuitem, "activate", G_CALLBACK(prefix_edit_callback), frame);
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);

			gtk_widget_show_all(menu);
			g_signal_connect(button, "clicked", G_CALLBACK(popup), menu);
			
		button = gtk_button_new_with_label("Set Staff Group Start/End");
		mark_as_non_custom(button);
		gtk_box_pack_start(GTK_BOX (staff_hbox), button, FALSE, TRUE, 0);
		gtk_widget_set_tooltip_text(button, "The braces { and [ binding staffs together can be set here. Set the start on one staff and the end on a later staff.\nThis is editing the score, not just customizing a layout.\nRefresh the layout view (see under Options for this Layout button at the top) once you have made the changes.");
		g_signal_connect(button, "button-press-event", G_CALLBACK(staff_groups_menu), (gpointer)get_location(movementnum, voice_count));
		
		*pstaffs = g_list_append(*pstaffs, frame);
		g_signal_connect(G_OBJECT(frame), "destroy", G_CALLBACK(remove_from_staff_list), pstaffs);
		
		GString *staffprefix = g_string_new("");
		set_staff_definition(staffprefix, staff, staff->denemo_name->str);

		
	  if (staff->no_of_lines != 5)
			g_string_append_printf(staffprefix, TAB"\\override Staff.StaffSymbol  #'line-count = #%d\n", staff->no_of_lines);//FIXME create_element
   
		add_lilypond(frame, g_string_free(staffprefix, FALSE), g_strdup("\n>>\n%End of Staff\n"));


		
		gtk_box_pack_start(GTK_BOX (vbox), frame, FALSE, TRUE, 0);

		GtkWidget *hbox = gtk_hbox_new (FALSE, 8);
		gtk_container_add (GTK_CONTAINER (frame), hbox);
		add_staff_widget(staff, hbox);
		
		label_text = (nextstaff && nextstaff->voicecontrol&DENEMO_SECONDARY)?"Voices":"Voice";
		GtkWidget *expander  = gtk_expander_new(label_text);
		//gtk_container_add (GTK_CONTAINER (frame), expander);
		gtk_box_pack_end(GTK_BOX(hbox), expander, FALSE, TRUE, 0);
		GtkWidget *voices_vbox = gtk_vbox_new(FALSE, 8);
		gtk_container_add (GTK_CONTAINER (expander), voices_vbox);

		if(staff->hasfigures) {
		GtkWidget *voice = gtk_label_new("Bass figures");
		gchar *text = g_strdup_printf( "\n"TAB TAB"\\context Staff \\with {implicitBassFigures = #'(0) } \\%sBassFiguresLine %%End of bass figures\n",
					get_voicename(movementnum, voice_count));
		add_lilypond(voice, text, NULL);
		gtk_box_pack_start (GTK_BOX (voices_vbox), voice, FALSE, TRUE, 0);
		}
#if 0      //These have to be placed outside the staff frame to appear above
		if(staff->hasfakechords) {
		GtkWidget *voice = gtk_label_new("chord symbols");		
		gchar *text = g_strdup_printf("\n"TAB TAB"\\new ChordNames \\chordmode { \\%sChords }\n", 
				   get_voicename(movementnum, voice_count));
		add_lilypond(voice, text, NULL);
		gtk_box_pack_start (GTK_BOX (voices_vbox), voice, FALSE, TRUE, 0);
		}
#endif
		install_voice(staff, movementnum, voice_count, voices_vbox); //Primary voice
		do_verses(staff, vbox, movementnum, voice_count);
		
		if(nextstaff && (nextstaff->voicecontrol&DENEMO_SECONDARY)) {	
			for(g=g->next, voice_count++;g && (((DenemoStaff*)g->data)->voicecontrol&DENEMO_SECONDARY);g=g->next, voice_count++) {
				
				DenemoStaff *staff = g->data;
				install_voice(staff, movementnum, voice_count, voices_vbox);
				do_verses(staff, vbox, movementnum, voice_count);//!!! these need *pstaffs = g_list_append(*pstaffs, voice); treatment too...
				if(partname==NULL)
					vbox = install_staff_group_end(vbox, staff->staff_directives, &staff_group_nesting);	
			}			
			if(g!=NULL)
				{
					 g = g->prev;
					 voice_count--;
			}
	}
	if(partname==NULL)
		vbox = install_staff_group_end(vbox, staff->staff_directives, &staff_group_nesting);
	if(g==NULL)
		break;
	} //for each staff

	if(staff_group_nesting<0) {
		g_critical("Impossible staff group nesting");
	} else {
		
		for(;staff_group_nesting;staff_group_nesting--) {
			g_warning("Staff group start without end - terminating it");
			add_lilypond(vbox, NULL, g_strdup(" >>%Missing staff group end inserted here\n"));
		}
	} 
	return ret;
}

/* append the data labeled with affix on the widget s to the out string */
static void append_lilypond_for_affix(const gchar *affix, GtkWidget *w, GString *out) {
		GList *g;
	for(g=(GList*)g_object_get_data(G_OBJECT(w), affix);g;g=g->next) {
		gchar *text = (gchar*)g->data;
		if(text)
		g_string_append(out, text);
	}
}

/* go through the layout appending score block elements to the out string */
static void lilypond_for_layout(GString *out, GtkWidget *layout) {
	append_lilypond_for_affix ("prefix", layout, out);
	if(GTK_IS_CONTAINER(layout)) {
		GList *g = gtk_container_get_children(GTK_CONTAINER(layout));
		if(g)
		do {
			lilypond_for_layout(out, g->data);
		} while ((g=g->next));
	}
	append_lilypond_for_affix ("postfix", layout, out);
}

//return a newly allocated name for a standard scoreblock
static gchar *movement_part_name(gint movement, gchar *partname) {
if(movement && partname)
	return g_strdup_printf("%s M%d", partname, movement);
if(movement)
	return g_strdup_printf("Movement %d", movement);
if(partname)
	return g_strdup_printf("%s", partname);
return g_strdup("Default Score Layout");
}

static GtkWidget *get_colored_event_box(GtkWidget *vbox, gchar *colorstring) {
		GtkWidget *event_box = gtk_event_box_new();
		gtk_box_pack_start(GTK_BOX(vbox), event_box, FALSE, TRUE, 0);	
		GdkColor color;
		if(gdk_color_parse (colorstring,&color))
			gtk_widget_modify_bg (event_box, GTK_STATE_NORMAL, &color);
		return event_box;
}

static void create_misc_scorewide(GtkWidget *inner_vbox) {
	DenemoGUI *gui = Denemo.gui;
	GtkWidget *expander = gtk_expander_new("LilyPond Paper Block");
	gtk_widget_set_tooltip_text(expander, _("LilyPond text that needs to be inside a \\paper{} block. Most users can ignore this!\n"));
	add_lilypond (expander,g_strdup("\\paper {\n"), g_strdup("\n}\n"));
	gtk_box_pack_start(GTK_BOX(inner_vbox), expander, FALSE, TRUE, 0);
	GtkWidget *paper_box = gtk_vbox_new(FALSE, 8);
	gtk_container_add(GTK_CONTAINER(expander), paper_box);

	create_element(paper_box, gtk_button_new_with_label("the paper block contents"), get_lilypond_paper());

	gchar *lily = g_strdup_printf("#(set-default-paper-size \"%s%s\")\n", gui->lilycontrol.papersize->str, gui->lilycontrol.orientation?"":" 'landscape");
	create_element(inner_vbox, gtk_button_new_with_label("paper size"),lily);
  lily = g_strdup_printf("#(set-global-staff-size %s)\n",  gui->lilycontrol.staffsize->str);
	create_element(inner_vbox, gtk_button_new_with_label("global staff size"),lily);
	}
static void create_scoreheader_directives(GtkWidget *vbox) {
	DenemoGUI *gui = Denemo.gui;
	GtkWidget *frame = gtk_frame_new(NULL);
	gtk_box_pack_start(GTK_BOX(vbox), frame, FALSE, TRUE, 0);
	GtkWidget *top_expander = gtk_expander_new("Score Header Directives");
	add_lilypond (top_expander,g_strdup("\n\\header {\n"), g_strdup("\n}\n"));
	gtk_widget_set_tooltip_text(top_expander, _("Settings for the LilyPond header block for the whole score.\nIncludes ..."));
	gtk_container_add (GTK_CONTAINER (frame), top_expander);
	GtkWidget *header_box = gtk_vbox_new(FALSE, 8);
	gtk_container_add(GTK_CONTAINER(top_expander), header_box);
	 
	gchar *default_tagline = g_strdup_printf("tagline = \\markup {%s on \\simple #(strftime \"%%x\" (localtime (current-time)))}\n", gui->filename->str);		
	create_element(header_box, gtk_label_new("Default tagline"), default_tagline);
	
	GList *g;
	for(g=gui->scoreheader.directives;g;g=g->next){
		DenemoDirective *directive = (DenemoDirective*)g->data;
		if(directive->override & (DENEMO_OVERRIDE_AFFIX|DENEMO_OVERRIDE_HIDDEN))
			continue;
		if(directive->postfix==NULL)
			continue;
		create_element(header_box, gtk_label_new(directive->tag->str), g_strdup(directive->postfix->str));
	}
}
static void create_score_directives(GtkWidget *vbox) {
	DenemoGUI *gui = Denemo.gui;
	GtkWidget *frame = gtk_frame_new(NULL);
	gtk_box_pack_start(GTK_BOX(vbox), frame, FALSE, TRUE, 0);
	GtkWidget *top_expander = gtk_expander_new("Score Directives");
	gtk_widget_set_tooltip_text(top_expander, _("Settings for the LilyPond for the whole score.\nIncludes ..."));
	gtk_container_add (GTK_CONTAINER (frame), top_expander);
	GtkWidget *inner_vbox = gtk_vbox_new(FALSE, 8);
	gtk_container_add(GTK_CONTAINER(top_expander), inner_vbox);
	
	GList *g = gui->lilycontrol.directives;
  for(;g;g=g->next) {
    DenemoDirective *directive = g->data;
    if(directive->prefix && !(directive->override&(DENEMO_OVERRIDE_AFFIX))) {
			GtkWidget *label = gtk_label_new(directive->tag->str);
			create_element(inner_vbox, label, g_strdup(directive->prefix->str)); 
		}
	}
}
	
static void create_scorewide_block(GtkWidget *vbox) {
	DenemoGUI *gui = Denemo.gui;
	GtkWidget *event_box = get_colored_event_box(vbox, "#AAFFBB");
	GtkWidget *frame = gtk_frame_new(NULL);
	gtk_container_add(GTK_CONTAINER(event_box), frame);
	GtkWidget *expander = gtk_expander_new("Score-wide Settings.");
	gtk_widget_set_tooltip_text(expander, _("Setting the score title, composer, headers and footers for this layout"));
	gtk_container_add(GTK_CONTAINER(frame), expander);
	
  GtkWidget *inner_box = gtk_vbox_new(FALSE, 8);
	gtk_container_add(GTK_CONTAINER(expander), inner_box);

//move these inside the scoreheader_directives box...
//EEEK FIXME the includes and #sets are inside the \\header it is being done above!!! it needs to be done inside create scoreheader
//and default_tagline needs to go inside that...
		
	GtkWidget *button = gtk_button_new_with_label(_("Create Book Titles"));
	mark_as_non_custom(button);

	gtk_widget_set_tooltip_text(button, _("Set book titles for the score"));
	g_signal_connect(button, "clicked", G_CALLBACK(popup_score_menu), NULL);
	gtk_box_pack_start(GTK_BOX(inner_box), button, FALSE, TRUE, 0);

	
	

	create_scoreheader_directives(inner_box);
	create_score_directives(inner_box);
	create_misc_scorewide(inner_box);
}
//populates the scoreblock *psb with the movement or movements for partname from the current score Denemo.gui
static void set_default_scoreblock(DenemoScoreblock **psb, gint movement, gchar *partname) {
	DenemoGUI *gui = Denemo.gui;
	(*psb)->staff_list = NULL;//list of staff frames in order they appear in scoreblock

	#if 0
	(*psb)->widget = gtk_frame_new(NULL);
	#else
	(*psb)->widget = gtk_scrolled_window_new(NULL, NULL);
	#endif

	
	(*psb)->visible = FALSE;//will be set true when/if tab is selected
	if(partname)
		(*psb)->partname = g_strdup(partname);
	(*psb)->movement = movement;
	layout_sync = (*psb)->layout_sync = gui->layout_sync;

	
	GtkWidget *vbox = gtk_vbox_new(FALSE, 8);
	gtk_scrolled_window_add_with_viewport (GTK_SCROLLED_WINDOW((*psb)->widget), vbox);
	GtkWidget *options = get_options_button(*psb);
	gtk_box_pack_start (GTK_BOX(vbox), options, FALSE, FALSE, 0);
	//now create a hierarchy of widgets representing the score
	create_scorewide_block(vbox);
	
	GList *g;
	gint movement_num = 1;
	for(g = gui->movements;g;g=g->next, movement_num++) {
		if(movement==0 /*all movements */|| (movement==movement_num) /*this movement*/) {
			DenemoScore *si = (DenemoScore *)g->data;
			gchar *label_text = gui->movements->next?g_strdup_printf("Movement %d", movement_num):NULL;
			GtkWidget *movement_frame = gtk_expander_new(label_text);
			gtk_expander_set_expanded(GTK_EXPANDER(movement_frame), si==gui->si);
			g_free(label_text);
			gtk_box_pack_start (GTK_BOX (vbox), movement_frame,  FALSE, TRUE, 0);
			GtkWidget *movement_vbox = gtk_vbox_new(FALSE, 8);
			gtk_container_add (GTK_CONTAINER (movement_frame), movement_vbox);
			install_pre_movement_widgets(movement_vbox, si);
			GtkWidget *frame = gtk_frame_new(NULL);
			add_lilypond(frame, g_strdup("\n\\score { %Start of Movement\n"), g_strdup("\n} %End of Movement\n"));
			gtk_box_pack_start (GTK_BOX (movement_vbox), frame,  FALSE, TRUE, 0);
			GtkWidget *outer_vbox = gtk_vbox_new(FALSE, 8);
			gtk_container_add (GTK_CONTAINER (frame), outer_vbox);
			
			
			GtkWidget *hbox = gtk_hbox_new(FALSE, 8);
			GtkWidget *button = gtk_button_new_with_label("X");
			gtk_box_pack_end(GTK_BOX (hbox), button, FALSE, TRUE, 0);
			g_signal_connect(button, "clicked", G_CALLBACK(remove_element), NULL);
			gtk_box_pack_start (GTK_BOX (hbox), get_movement_widget(&(*psb)->staff_list, partname, si, movement_num, !(gboolean)g->next, !gui->movements->next), FALSE, TRUE, 0);
			gtk_box_pack_start(GTK_BOX (outer_vbox), hbox, FALSE, TRUE, 0);
		if(si->header.directives) {
			GtkWidget *frame = gtk_frame_new("Header block");
			gtk_box_pack_start(GTK_BOX(outer_vbox), frame, FALSE, TRUE, 0);
			add_lilypond(frame, g_strdup("\n\\header {\n"), g_strdup("\n}\n"));
			GtkWidget *innerbox = gtk_vbox_new(FALSE, 8);
			gtk_container_add(GTK_CONTAINER(frame), innerbox);
			GList *g;
			for(g=si->header.directives;g;g=g->next) {
				DenemoDirective *d = g->data;
				if(d->override & DENEMO_OVERRIDE_HIDDEN)
					continue;
				
				gchar *lily = (d->postfix && d->postfix->len)?d->postfix->str:NULL;
				if(lily) {
					create_element(innerbox, gtk_button_new_with_label(d->tag->str), g_strdup(lily));
				}
			}
		}
		if(si->layout.directives) {
			GtkWidget *frame = gtk_frame_new("Layout block");
			gtk_box_pack_start(GTK_BOX(outer_vbox), frame, FALSE, TRUE, 0);
			add_lilypond(frame, g_strdup("\n\\layout {\n"), g_strdup("\n}\n"));
			GtkWidget *innerbox = gtk_vbox_new(FALSE, 8);
			gtk_container_add(GTK_CONTAINER(frame), innerbox);
			GList *g;
			for(g=si->layout.directives;g;g=g->next) {
				DenemoDirective *d = g->data;
				if(d->override & DENEMO_OVERRIDE_HIDDEN)
					continue;
				
				gchar *lily = (d->postfix && d->postfix->len)?d->postfix->str:NULL;
				if(lily) {
					create_element(innerbox, gtk_button_new_with_label(d->tag->str), g_strdup(lily));
				}
			}
		}
			
		}	//if movement is wanted
	} //for all movements

	 for(g=gui->lilycontrol.directives;g;g=g->next) {
    DenemoDirective *d = g->data;
    if(d->override & DENEMO_OVERRIDE_HIDDEN)
			continue;
		if(!(d->override & DENEMO_OVERRIDE_AFFIX))
			continue;
		gchar *post = (d->postfix && d->postfix->len)?d->postfix->str:NULL;
		if(post) {
			create_element(vbox, gtk_button_new_with_label(d->tag->str), g_strdup(post));
			}
		}
		

}

//recompute a standard scoreblock
static void recreate_standard_scoreblock(DenemoScoreblock **psb) {
	gint movement = (*psb)->movement;
	gchar *partname = (*psb)->partname?g_strdup((*psb)->partname):NULL;
	gboolean visible = (*psb)->visible;
	free_scoreblock((*psb)); //this changes the page in the notebook if it was selected before. So if sb->visible then re-select this page after reconstruction
	create_standard_scoreblock(psb, movement, partname);
	if(visible)
		gtk_notebook_set_current_page(GTK_NOTEBOOK(get_score_layout_notebook(Denemo.gui)), 0);
}
//return value must not be freed
static const gchar *scoreblock_name(DenemoScoreblock *sb) {
	return gtk_notebook_get_tab_label_text(GTK_NOTEBOOK(get_score_layout_notebook(Denemo.gui)), sb->widget);
}



//refreshes the lilypond field of all the standard scoreblocks after re-computing the standard scoreblocks already present
//does nothing if structure has not changed since they were computed. Warns if custom scoreblocks are present
static gboolean check_for_update(void){
	DenemoGUI *gui = Denemo.gui;
	if(gui->layout_sync > layout_sync) {
		GList *g;
		for(g=gui->standard_scoreblocks;g;g=g->next) {
				DenemoScoreblock *sb = (DenemoScoreblock*)g->data;
				recreate_standard_scoreblock(&sb);
		}
		//if(gui->custom_scoreblocks)
		//	warningdialog("You have customized layouts which may not work with the new structure of your score.");
	}
	return TRUE;
}

static gboolean change_tab (GtkNotebook *notebook, GtkWidget *page, gint pagenum) {
 //this is getting called with pagenum 0 when clicking on the lilypond text window...
		Denemo.gui->lilysync = G_MAXUINT;
		page = gtk_notebook_get_nth_page(notebook, pagenum); // value passed in appears to be something else - it is not documented what.

		GList *g;
		for(g=Denemo.gui->custom_scoreblocks;g;g=g->next) {
			DenemoScoreblock *sb = ((DenemoScoreblock*)g->data);
			sb->visible = (sb->widget == page);
		}
	  for(g=Denemo.gui->standard_scoreblocks;g;g=g->next) {
			DenemoScoreblock *sb = ((DenemoScoreblock*)g->data);
			sb->visible = (sb->widget == page);
		}
	return TRUE;
}

//takes a DenemoScoreblock that has a valid widget field and recomputes the lilypond field of the scoreblock
//from the widget. It also sets the name field of the scoreblock to the name on the Notebook tab.
void refresh_lilypond(DenemoScoreblock *sb) {
	if(sb->widget) {
		if(!is_lilypond_text_layout(sb)) {
			sb->name = g_strdup(scoreblock_name(sb));
			sb->id = crc32(sb->name);
			if(sb->lilypond==NULL)
				sb->lilypond = g_string_new(sb->name);
			else
				g_string_assign(sb->lilypond, sb->name);
			g_string_prepend(sb->lilypond, "%");
			g_string_append(sb->lilypond, "\n");
			lilypond_for_layout(sb->lilypond, sb->widget);
		}
	} else
	g_warning("No widget for scoreblock");
}

DenemoScoreblock *selected_scoreblock(void) {
	GtkWidget *notebook = get_score_layout_notebook(Denemo.gui);
	gint pagenum = gtk_notebook_get_current_page(GTK_NOTEBOOK(notebook)); // value passed in appears to be something else - it is not documented what.
	GtkWidget *page = gtk_notebook_get_nth_page(GTK_NOTEBOOK(notebook), pagenum);
	GList *g;
	for(g=Denemo.gui->custom_scoreblocks;g;g=g->next) {
			DenemoScoreblock *sb = ((DenemoScoreblock*)g->data);
			if(sb->widget == page){
				refresh_lilypond(sb);
				return sb;
			}
	}
	for(g=Denemo.gui->standard_scoreblocks;g;g=g->next) {
			DenemoScoreblock *sb = ((DenemoScoreblock*)g->data);
			if(sb->widget == page) {
				refresh_lilypond(sb);
				return sb;
			}
	}
	return NULL;
}

guint selected_layout_id(void) {
DenemoScoreblock *sb = selected_scoreblock();
if(sb) return sb->id;
return 0;
}

GtkWidget *get_score_layout_notebook(DenemoGUI *gui) {
	GtkWidget *notebook = gtk_bin_get_child(GTK_BIN(gui->score_layout));
	if(notebook==NULL) {
		notebook = gtk_notebook_new();
		g_signal_connect(notebook, "switch_page", G_CALLBACK(change_tab), NULL);
		g_signal_connect(gui->score_layout, "focus-in-event", G_CALLBACK(check_for_update), NULL);	
		gtk_container_add (GTK_CONTAINER (gui->score_layout), notebook);
	}
	return notebook;
}
	
//create a standard scoreblock in the passed DenemoScoreblock structure and put it in a new tab in the score
//does not add it to the standard scoreblocks list
static void create_standard_scoreblock(DenemoScoreblock **psb, gint movement, gchar *partname) {
	DenemoGUI *gui = Denemo.gui;
	GtkWidget *notebook = get_score_layout_notebook(gui);
	set_default_scoreblock(psb, movement, partname);
	
	gchar *label_text = movement_part_name(movement, partname);
	GtkWidget *label = gtk_label_new(label_text);
	g_free(label_text);
	gtk_notebook_prepend_page(GTK_NOTEBOOK(notebook), (*psb)->widget, label);
	gtk_widget_show_all(notebook);
	
}

static void set_notebook_page(GtkWidget *w) {
	GtkWidget *notebook = get_score_layout_notebook(Denemo.gui);
	GList *g = gtk_container_get_children(GTK_CONTAINER(notebook));
	gint position = g_list_index(g, w);g_print("pos %d", position);
	g_list_free(g);
	gtk_notebook_set_current_page(GTK_NOTEBOOK(notebook), position);
}
//creates the all parts all movements standard scoreblock 
void create_default_scoreblock(void) {
	DenemoGUI *gui = Denemo.gui;
	if(gui->standard_scoreblocks)
		g_warning("create_default_scoreblock called with standard scoreblocks already present\n");
	DenemoScoreblock *sb = g_malloc0(sizeof(DenemoScoreblock));
	(void)create_standard_scoreblock(&sb, 0, NULL);
	gui->standard_scoreblocks = g_list_prepend(gui->standard_scoreblocks, (gpointer)sb);
}


//if no custom scoreblock is selected, selects or creates a standard one for the given 
DenemoScoreblock *select_layout(gboolean all_movements, gchar *partname) {
	GList *g;
	DenemoScoreblock *sb;
	//make sure at least the default scoreblock has been created
	if(Denemo.gui->standard_scoreblocks==NULL) {
		create_default_scoreblock();
		sb = (DenemoScoreblock*)(Denemo.gui->standard_scoreblocks->data);
		refresh_lilypond(sb);//creating a scoreblock does *not* include generating the lilypond from its widgets.
	}


	
	gboolean layout_selected = gtk_widget_get_visible(Denemo.gui->score_layout);

	
	if(layout_selected && (all_movements && partname==NULL)) {
		sb =  selected_scoreblock();
		if(sb) {
			if(is_in_standard_scoreblock(sb)) {
				recreate_standard_scoreblock(&sb);
				refresh_lilypond(sb);
			}
			set_notebook_page(sb->widget);
			return sb; //!!! this is the only case where a custom scoreblock can be returned.
		}
	}

	
//otherwise return a standard scoreblock recreating it - though this should only need doing if changecount has moved on

//first recreate all the standard scoreblocks and set them not visible
	for(g=Denemo.gui->standard_scoreblocks;g;g=g->next) {
		sb = (DenemoScoreblock*)g->data;
		//	if(sb->layout_sync!=Denemo.gui->layout_sync)
		recreate_standard_scoreblock(&sb);
		sb->visible = FALSE;
	}

	if(all_movements && partname==NULL) { //select the one for the whole score
		for(g=Denemo.gui->standard_scoreblocks;g;g=g->next) {
			sb = (DenemoScoreblock*)g->data;
			if((sb->movement==0) && (sb->partname==NULL)) {
				sb->visible = TRUE;
				refresh_lilypond(sb);
				set_notebook_page(sb->widget);
				return sb;
			}
		}
		g_warning("Error in logic: the default standard scoreblock should exist ");
	}	else { //Not a whole score print
			for(g=Denemo.gui->standard_scoreblocks;g;g=g->next) {
				sb = (DenemoScoreblock*)g->data;

				//a good match to partname ?
				gboolean good = (sb->partname && partname && !strcmp(sb->partname, partname)) || (sb->partname==NULL && partname==NULL);
				
			if(good && (all_movements && (sb->movement==0))) { //scoreblock is for good partname and is for all movements - use it
				sb->visible = TRUE;
				refresh_lilypond(sb);
				set_notebook_page(sb->widget);
				return sb;
			}
		}
	}

//either just the current movement or just the part named or both. Set up the movement number (1 ...) or 0 for the all movements case	
	gint movement; 
	if(all_movements) {
		movement = 0;
	} else {
		movement = g_list_index(Denemo.guis, Denemo.gui) + 1; //current movement
	}


	if(movement || partname) { //a specific movement and/or a specific part
	 for(g=Denemo.gui->standard_scoreblocks;g;g=g->next) {
			sb = (DenemoScoreblock*)g->data;
			if((movement==sb->movement) && ((partname==sb->partname) || (partname && sb->partname && !strcmp(sb->partname, partname)))) {
				sb->visible = TRUE;
				refresh_lilypond(sb);
				set_notebook_page(sb->widget);
				return sb;
			}
	 }
		sb = g_malloc0(sizeof(DenemoScoreblock));
		create_standard_scoreblock(&sb, movement, partname);
		Denemo.gui->standard_scoreblocks = g_list_prepend(Denemo.gui->standard_scoreblocks, sb);
		sb->visible = TRUE;
		refresh_lilypond(sb);
		set_notebook_page(sb->widget);
		return sb;
	}
	//NOT REACHED
	g_warning("Error in logic: the default standard scoreblock should exist abd be returned ");
	return sb;//this is the last in the list of standard scoreblocks but cannot be reached
}

static text_modified(GtkTextBuffer *textbuffer, DenemoScoreblock *sb) {
  GtkTextIter startiter, enditer;
  gtk_text_buffer_get_start_iter (textbuffer, &startiter);
  gtk_text_buffer_get_end_iter (textbuffer, &enditer);
  gchar *text = gtk_text_buffer_get_text (textbuffer, &startiter, &enditer, FALSE);
  if(sb->lilypond)
    g_string_assign(sb->lilypond, text);
  else
    sb->lilypond = g_string_new(text);
  score_status(Denemo.gui, TRUE);
}

    
DenemoScoreblock *get_scoreblock_for_lilypond(gchar *lily) {
	  gchar *name = NULL;
		GtkWidget *frame = gtk_frame_new(LILYPOND_TEXT_EDITOR);
		DenemoScoreblock *sb = g_malloc0 (sizeof(DenemoScoreblock));
		sb->widget = frame;
		GtkWidget *vbox = gtk_vbox_new(FALSE, 8);
		gtk_container_add (GTK_CONTAINER (sb->widget), vbox);
		GtkWidget *options = get_options_button(sb);
		gtk_box_pack_start (GTK_BOX(vbox), options, FALSE, FALSE, 0);
		GtkWidget *textview = gtk_text_view_new();
		gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(textview), TRUE);
		//g_print("Value %d\n", gtk_text_view_get_cursor_visible(GTK_TEXT_VIEW(textview)));
		GtkTextBuffer *textbuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(textview));
		gtk_text_buffer_set_text(textbuffer, lily, -1);

		GtkWidget *sw = gtk_scrolled_window_new (NULL, NULL);
		gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (sw),
				  GTK_POLICY_AUTOMATIC,
				  GTK_POLICY_AUTOMATIC);
		gtk_container_add (GTK_CONTAINER (sw), textview);
		gtk_box_pack_start (GTK_BOX (vbox), sw, TRUE, TRUE, 0);
		gchar *newline = g_strstr_len(lily, -1, "\n");
		if(newline) {
			name = g_strndup(lily, newline - lily);
			sb->name = g_strdup(name+1);
			sb->id = crc32(sb->name);
			g_free(name);
		} else
		sb->name = g_strdup("Custom Scoreblock");
		sb->id = crc32(sb->name);
		sb->lilypond = g_string_new(lily);
		g_signal_connect_after (G_OBJECT (textbuffer), "changed",
		      G_CALLBACK (text_modified), sb);

		refresh_lilypond(sb);
    return sb;
}

//if the score_layout window is visible and a standard scoreblock is selected, create a custom one cloned from it with the passed name
gboolean create_custom_scoreblock (gchar *layout_name) {
	GList *g;
	if(!gtk_widget_get_visible(Denemo.gui->score_layout))
		return FALSE;
	for(g=Denemo.gui->custom_scoreblocks;g;g=g->next) {
		DenemoScoreblock *sb = (DenemoScoreblock *)g->data;
		if(!strcmp(layout_name, sb->name))
			return FALSE;
	}
	for(g=Denemo.gui->standard_scoreblocks;g;g=g->next) {
		DenemoScoreblock *sb = (DenemoScoreblock *)g->data;
		if(sb->visible) {
			clone_scoreblock(sb, layout_name);
			return TRUE;
		}
	}
	return FALSE;
}
